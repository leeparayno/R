{
    "contents" : "## makeCacheMatrix(x)\n##      This function takes a matrix as an argument\n##      and will return a \"cacheable\" matrix\n##      Used in conjunction with cacheSolve, it is capable\n##      of solving for the inverse of a matrix, and then\n##      cacheing the result, before returning, upon the first execution.\n##      subsequent executions of cacheSolve will return the cached inverse.\n##\n##  Arguments:  x - shoulmad be an invertable matrix\n##\n## Example Use:\n## 1. For an invertible matrix:\n##      > A <- matrix(c(4,4,-2,2,6,2,2,8,4),3,3)\n## 2. Create a cacheable matrix\n##      > A2 <- makeCacheMatrix(A)\n## \n## Methods available:\n##  <cacheMatrix>$set   - sets a new value for the matrix to be inverted\n##  <cacheMatrix>$get   - gets the specified original matrix\n##  <cacheMatrix>$setinverse - sets the calculated inverse into a cached location\n##  <cacheMatrix>$getinverse - return the cached version of the inverse\n##\nmakeCacheMatrix <- function(x = matrix()) {\n    anInverse <- NULL\n    matrixChanged <- FALSE\n    ## sets the matrix to be inverted\n    set <- function(y) {\n        x <<- y\n        anInverse <<- NULL\n        matrixChanged <<- TRUE\n    }\n    ## return the orignial matrix\n    get <- function() x\n    ## cache the inverse of the specified matrix\n    setinverse <- function(inv) anInverse <<- inv\n    ## retrieve the inverse\n    getinverse <- function() {\n        if (matrixChanged == TRUE) {\n            stop(\"matrix has changed, please rerun cacheSolve\")\n        }\n        anInverse\n    }\n    ## combine the functions\n    list(set = set, get = get,\n         setinverse = setinverse,\n         getinverse = getinverse)    \n}\n\n\n## cacheSolve - This function will return the inverse of a matrix\n##              It has the added capability of cacheing the resulting\n##              inverse after the first execution.  For subsequent \n##              executions of cacheSolve, the cached inverse will \n##              be returned.  For larger matrices,\n##              this performance optimization can lead to huge gains\n##              depending on the logic of your program\n##\n## Arguments:   x - is a cacheable matrix made by makeCacheMatrix\n##\n## Example Use:\n## 1. For an invertible matrix:\n##      > A <- matrix(c(4,4,-2,2,6,2,2,8,4),3,3)\n## 2. Create a cacheable matrix\n##      > A2 <- makeCacheMatrix(A)\n## 3. Execute cacheSolve, to generate and cache the inverse for future executions\n##      > cacheSolve(A2)        ## First execution will solve for the inverse and cache it\n##       [,1] [,2] [,3]\n## [1,]  1.0 -0.5  0.5\n## [2,] -4.0  2.5 -3.0\n## [3,]  2.5 -1.5  2.0\n##\n##      > cacheSolve(A2)        ## This is the second exection and should return \n## getting cached data\n##       [,1] [,2] [,3]\n## [1,]  1.0 -0.5  0.5\n## [2,] -4.0  2.5 -3.0\n## [3,]  2.5 -1.5  2.0\n\ncacheSolve <- function(x, ...) {\n    ## Return a matrix that is the inverse of 'x'\n    \n    anInverse <- x$getinverse()\n    \n    ## This checks if the inverse was already calculated before\n    ## If so, the cached inverse is returned\n    if(!is.null(anInverse)) {\n        message(\"getting cached data\")\n        return(anInverse)\n    }\n    \n    ## Retrieve the original matrix\n    data <- x$get()\n    \n    ## Solve for the inverse\n    anInverse <- solve(data, ...)\n    \n    ## Cache the inverse\n    x$setinverse(anInverse)\n    \n    ## Return the calculated inverse/cached inverse\n    anInverse    \n}\n",
    "created" : 1445272210849.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "599154801",
    "id" : "A06B7FF9",
    "lastKnownWriteTime" : 1445405670,
    "path" : "~/git/R/week3/cachematrix.R",
    "project_path" : "cachematrix.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}